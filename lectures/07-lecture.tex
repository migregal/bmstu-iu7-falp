\chapter{Лекция 7}

в базе знаний нет порядка.

Вопрос тоже мб без переменных -> основные и неосновные (исп переменных — повышение уровня абрстракции)

Переменные.

Именованные, когда исп, не имеют значение, подбираетсяя. Но в какой момент она какое значение принимает. Методом проб и ошибок. Цель — подтвердить истинность вопроса с помощью бз.

Именованные - передача значения во времени и пространстве (для этого в какой-то момент переменная дб конкретизирована каким-то значением. Но это может быть ошибочным, есть механизм отказа, реконкретизировать переменную). Установление значения длля переменной не связано с понятием типа (по указателям). Анонимные переменные система не конкретизирует значениями.

Алгоритм унификации - единственный алгоритм доказательства. Многократно запускается (в какой момент?)

про переменные — ...

Каждое утверждение программы — ...



Вопросы простые. Пока просто факты.

именованная переменная входит в факты и правила с квантором всеобщности, а в вопрос с квантором существования.

Уникальность: именованная переменная уникальна в рамках одного предложения. Анонимная переменная уникальна всегда.

вообще мы знаем об объектах, набор характеристик.

Заголовок — составной терм (главный функтор и аргументы в скобочках) — фиксирует знание о том что между аргументами существует связь, имя которой является главным функтором. Известный объект - символами, неизвестный - переменная.

Заголовок — правило, тело — условие.

Факт - чс правила, пустое тело.

В момент фиксации знания (если еще оно с условием, переменными) — условная истина.

\section*{процедрные и декларативные особенности пролога}

Чтобы подобрать знание (которое в заголовке). Чтобы ответить на вопрос, надо подобрать знание — надо сравнивать вопрос с заголовками. Порядок формально установлен сверху вниз. Система формально (используя только конструкцию - симв .. и порядок) подбирает знание. И то, и то — составной терм. Сравнивает по 2 сосавных терма по формальному признаку.

Если есть переменная и в вопросе, и в формулировке знания (а если еще и на одной позиции)

\section*{подстановки и примеры терма}

Без переменных — основные.

Неосновные термы:

A(X1, ..., Xn), Xi — переменные.

Подстановкой называется множество пар вида {xi=ti}, где xi — переменная, ti — терм, не содержащий переменных (ti — значение для переменной xi).

Чтобы подбирать значения переменных нужно построить подстановвку. Прнято обозначать $teta$


$тета = {X1=t1, ..., Xn=Tn}$ — применение подстановки к терму


Применение подстановки заключается в замене каждого вхождения переменной Xi на соотв вхождение ti. Атета

Терм B явл примером терма А, если сущ такая подстановка тета, что

B=Aтета


Терм С называется общим примером термов А и B, если существуют такие подстановки тета1 и тета2, что С=Атета1 и С = Втета2.


A = plus(1, 2, z)
plus(X, Y, 3)


В первых лабах только факты, потом факты и правила, условие истинности разделено запятыми.

Запрещается использовать сложные вопросы — один терм.

father(X, Y), father(Y, Z)


Процедура — группу знаний объединяют в общее знание. Главный функтор у всех одинаковый. Природа объектов одинакова (не про память).

Процедура — совокупность правил, заголовки которых имеют одинаковые главные функторы, одинаковое число аргументов, обозначающих объекты одной природы.

Это одно знание, которое мб зафиксировано через несколько. Структура знания описывается в разделе предикатов. Не связано с понятием типа или памятью


\section{Простейшие правила логического вывода}

один составной терм

Правила вывода — утверждения о взаимосвязи между допущениями, которые с позиции исчисления предикатов верны всегда.

4 варианта
\begin{itemize}
    \item факты основные (квантор существования), вопрос основной — правило-совпадение
    \item факты основные, вопрос неосновной — правило — обобщение факта
    \item факты неосновные (квантор всеобщности), вопрос основной — правило конкретизации факта
    \item факты неосновные, вопрос неосновной — система должна построить пример терма-вопроса и терма-знания (подобрать
соотв подстановки) общий пример строится в 2 шага —- сначала конкретизация правила, а потом правило обобщения.
\end{itemize}

\section*{унификация терма}

комп по имеративному принципу. опять унификация.

унификация - операция, которая позволяет формализовать процесс логического вывода. Это основной вычислительный шаг, с помощью которого происходит

1. Двунаправленная передача парамтеров процедурам (знание в неск предложений)
2. Неразрушающее присваивание (конкретизация)
3. Проверка условий.


Унифицировать (понять, что это знание подходит для доказательства этого вопроса) два терма. Два терма про одно и то же (= — принудительный (явный) запуск унификации)

T1=T2


Два терма унификируются по след правилам

\begin{enumerate}
    \item Если T1 и T2 — константы: только если они совпадают
    \item Если T1 — неконкретизированная переменная, а Т2 — константа или составной терм, не содержащий в качестве аргумента Т1: унификация успешна, а Т1 конкретизируется значением Т2
    \item Если Т1 и Т2 — неконкретизированные (не имеющие значения) переменные: унификация всегда успешна, причем Т1 и Т2 становятсяя сцеплёнными двумя именами (указателями) одного и того же объекта.
    Если одна из переменных или один из термов конкретизивуется значением, то второй моментально тоже конкретизируется им же
    \item Если Т1 и Т2 — составные термы (напр вопрос и заголовок): успешно унифицируются если
    \begin{enumerate}
        \item у Т1 и Т2 одинаковые главные функторы
        \item Т1 и Т2 имеют равные арности
        \item успешно унифицируется каждая пара их соотв компонент
    \end{enumerate}
\begin{enumerate}

\section*{Алгоритм унификации}
